#! /bin/sh /usr/share/dpatch/dpatch-run
## 3131+3521.dpatch by Francesco Paolo Lovergine <frankie@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' proftpd-dfsg~/include/ftp.h proftpd-dfsg/include/ftp.h
--- proftpd-dfsg~/include/ftp.h	2011-01-13 10:50:55.000000000 +0100
+++ proftpd-dfsg/include/ftp.h	2011-01-25 10:01:10.000000000 +0100
@@ -2,7 +2,7 @@
  * ProFTPD - FTP server daemon
  * Copyright (c) 1997, 1998 Public Flood Software
  * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>
- * Copyright (c) 2001, 2002, 2003, 2004 The ProFTPD Project team
+ * Copyright (c) 2001-2008 The ProFTPD Project team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -32,6 +32,39 @@
 #ifndef PR_FTP_H
 #define PR_FTP_H
 
+/* Telnet codes; see RFC854 for details. */
+
+/* Telnet "Interpret As Command" indicator */
+#ifndef TELNET_IAC
+# define TELNET_IAC     255
+#endif
+
+#ifndef TELNET_DONT
+# define TELNET_DONT    254
+#endif
+
+#ifndef TELNET_DO
+# define TELNET_DO      253
+#endif
+
+#ifndef TELNET_WONT
+# define TELNET_WONT    252
+#endif
+
+#ifndef TELNET_WILL
+# define TELNET_WILL    251
+#endif
+
+/* Telnet "Interrupt Process" code */
+#ifndef TELNET_IP
+# define TELNET_IP      244
+#endif
+
+/* Telnet "Data Mark" code */
+#ifndef TELNET_DM
+# define TELNET_DM      242
+#endif
+
 /* Commands (minimum required supported level) */
 #define C_USER	"USER"		/* Specify a username */
 #define C_PASS	"PASS"		/* Specify a password */
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' proftpd-dfsg~/src/data.c proftpd-dfsg/src/data.c
--- proftpd-dfsg~/src/data.c	2011-01-13 10:50:55.000000000 +0100
+++ proftpd-dfsg/src/data.c	2011-01-25 10:04:11.000000000 +0100
@@ -451,6 +451,9 @@
 int pr_data_open(char *filename, char *reason, int direction, off_t size) {
   int res = 0;
 
+  /* Make sure that any abort flags have been cleared. */
+  session.sf_flags &= ~SF_ABORT;
+
   if (!session.xfer.p)
     data_new_xfer(filename, direction);
   else
@@ -897,6 +900,7 @@
   } else { /* PR_NETIO_IO_WR */
 
     while (cl_size) {
+      int bwrote = 0;
       int buflen = cl_size;
       unsigned int xferbuflen;
 
@@ -918,16 +922,19 @@
         xfrm_ascii_write(&session.xfer.buf, &xferbuflen, session.xfer.bufsize);
       }
 
-      if (pr_netio_write(session.d->outstrm, session.xfer.buf,
-          xferbuflen) < 0)
+      bwrote = pr_netio_write(session.d->outstrm, session.xfer.buf, xferbuflen);
+
+      if (bwrote < 0)
         return -1;
 
-      if (TimeoutStalled)
-        pr_timer_reset(TIMER_STALLED, ANY_MODULE);
+      if (bwrote > 0) {
+        if (TimeoutStalled)
+          pr_timer_reset(TIMER_STALLED, ANY_MODULE);
 
-      cl_size -= buflen;
-      cl_buf += buflen;
-      total += buflen;
+          cl_size -= buflen;
+          cl_buf += buflen;
+          total += buflen;
+      }
     }
 
     len = total;
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' proftpd-dfsg~/src/netio.c proftpd-dfsg/src/netio.c
--- proftpd-dfsg~/src/netio.c	2011-01-25 10:01:10.000000000 +0100
+++ proftpd-dfsg/src/netio.c	2011-01-25 10:01:10.000000000 +0100
@@ -29,22 +29,6 @@
 #include "conf.h"
 #include <signal.h>
 
-#ifndef IAC
-# define IAC	255
-#endif
-#ifndef DONT
-# define DONT	254
-#endif
-#ifndef DO
-# define DO	253
-#endif
-#ifndef WONT
-# define WONT	252
-#endif
-#ifndef WILL
-# define WILL	251
-#endif
-
 static const char *trace_channel = "netio";
 
 static pr_netio_t *core_ctrl_netio = NULL, *ctrl_netio = NULL;
@@ -619,10 +603,6 @@
         /* We have to potentially restart here as well, in case we get EINTR. */
         do {
           pr_signals_handle(); 
-
-          if (XFER_ABORTED)
-            break;
-
           run_schedule();
 
           switch (nstrm->strm_type) {
@@ -632,6 +612,9 @@
                 break;
 
             case PR_NETIO_STRM_DATA:
+              if (XFER_ABORTED)
+                break;
+
               bwritten = data_netio ? (data_netio->write)(nstrm, buf, buflen) :
                 (core_data_netio->write)(nstrm, buf, buflen);
               break;
@@ -916,12 +899,13 @@
   return buf;
 }
 
+static int telnet_mode = 0;
+
 char *pr_netio_telnet_gets(char *buf, size_t buflen,
     pr_netio_stream_t *in_nstrm, pr_netio_stream_t *out_nstrm) {
 
   char *bp = buf;
   unsigned char cp;
-  static unsigned char mode = 0;
   int toread, saw_newline = FALSE;
   pr_buffer_t *pbuf = NULL;
 
@@ -966,47 +950,73 @@
       cp = *pbuf->current++;
       pbuf->remaining++;
 
-      switch (mode) {
-        case IAC:
+      switch (telnet_mode) {
+        case TELNET_IAC:
           switch (cp) {
-            case WILL:
-            case WONT:
-            case DO:
-            case DONT:
-              mode = cp;
+            case TELNET_WILL:
+            case TELNET_WONT:
+            case TELNET_DO:
+            case TELNET_DONT:
+            case TELNET_IP:
+            case TELNET_DM:
+              /* Why do we do this crazy thing where we set the "telnet mode"
+               * to be the action, and let the while loop, on the next pass,
+               * handle that action?  It's because we don't know, right now,
+               * whether there actually a "next byte" in the input buffer.
+               * There _should_ be -- but we can't be sure.  And that next
+               * byte is needed for properly responding with WONT/DONT
+               * responses.
+               */
+              telnet_mode = cp;
               continue;
 
-            case IAC:
-              mode = 0;
-              break;
-
             default:
-              /* Ignore */
-              mode = 0;
-              continue;
+              /* In this case, we know that the previous byte was TELNET_IAC,
+               * but the current byte is not a value we care about.  So
+               * write the TELNET_IAC into the output buffer, break out of
+               * of the switch, and let that handle the writing of the
+               * current byte into the output buffer.
+               */
+              *bp++ = TELNET_IAC;
+              buflen--;
+
+              telnet_mode = 0;
+              break;
           }
           break;
 
-        case WILL:
-        case WONT:
-          pr_netio_printf(out_nstrm, "%c%c%c", IAC, DONT, cp);
-          mode = 0;
+        case TELNET_WILL:
+        case TELNET_WONT:
+          pr_netio_printf(out_nstrm, "%c%c%c", TELNET_IAC, TELNET_DONT, cp);
+          telnet_mode = 0;
           continue;
 
-        case DO:
-        case DONT:
-          pr_netio_printf(out_nstrm, "%c%c%c", IAC, WONT, cp);
-          mode = 0;
+        case TELNET_DO:
+        case TELNET_DONT:
+          pr_netio_printf(out_nstrm, "%c%c%c", TELNET_IAC, TELNET_WONT, cp);
+          telnet_mode = 0;
           continue;
 
+        case TELNET_IP:
+        case TELNET_DM:
         default:
-          if (cp == IAC) {
-            mode = cp;
+          if (cp == TELNET_IAC) {
+            telnet_mode = cp;
             continue;
           }
           break;
       }
 
+      /* In the situation where the previous byte was an IAC, we wrote IAC
+       * into the output buffer, and decremented buflen (size of the output
+       * buffer remaining).  Thus we need to check here if buflen is zero,
+       * before trying to decrement buflen again (and possibly underflowing
+       * the buflen size_t data type).
+       */
+      if (buflen == 0) {
+        break;
+      }
+
       *bp++ = cp;
       buflen--;
     }
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' proftpd-dfsg~/src/response.c proftpd-dfsg/src/response.c
--- proftpd-dfsg~/src/response.c	2011-01-13 10:50:55.000000000 +0100
+++ proftpd-dfsg/src/response.c	2011-01-25 10:01:10.000000000 +0100
@@ -61,6 +61,46 @@
   else \
     pr_netio_printf_async((strm), (fmt), (msg));
 
+static void filter_telnet_codes(char *buf, size_t bufsz) {
+  register unsigned int i;
+
+  for (i = 0; i < bufsz-1; i++) {
+    /* If we see an IAC followed by IP or DM, remove them. */
+    if (((unsigned char) buf[i]) == TELNET_IAC) {
+      if (((unsigned char) buf[i+1]) == TELNET_IP) {
+        pr_trace_msg("response", 3, "stripping Telnet IAC/IP sequence");
+
+        /* Ship everything in the buffer to the left 2 spaces, overwriting
+         * the IAC/IP bytes.
+         */
+
+        memmove(&(buf[i]), &(buf[i+2]), bufsz - 2 - i);
+        bufsz -= 2;
+
+        /* Decrement i by one, so that the next loop through examines the
+         * the data that we just moved into the current i-th position.
+         */
+        i--;
+
+      } else if (((unsigned char) buf[i+1]) == TELNET_DM) {
+        pr_trace_msg("response", 3, "stripping Telnet IAC/DM sequence");
+
+        /* Ship everything in the buffer to the left 2 spaces, overwriting
+         * the IAC/DM bytes.
+         */
+
+        memmove(&(buf[i]), &(buf[i+2]), bufsz - 2 - i);
+        bufsz -= 2;
+
+        /* Decrement i by one, so that the next loop through examines the
+         * the data that we just moved into the current i-th position.
+         */
+        i--;
+      }
+    }
+  }
+}
+
 void pr_response_set_pool(pool *p) {
   resp_pool = p;
 }
@@ -123,7 +163,10 @@
   va_end(msg);
   
   resp_buf[sizeof(resp_buf) - 1] = '\0';
-  
+
+  /* Make sure that we don't send any Telnet codes back in the response. */
+  filter_telnet_codes(resp_buf, sizeof(resp_buf));
+
   resp = (pr_response_t *) pcalloc(resp_pool, sizeof(pr_response_t));
   resp->num = (numeric ? pstrdup(resp_pool, numeric) : NULL);
   resp->msg = pstrdup(resp_pool, resp_buf);
@@ -148,6 +191,9 @@
 
   resp_buf[sizeof(resp_buf) - 1] = '\0';
   
+  /* Make sure that we don't send any Telnet codes back in the response. */
+  filter_telnet_codes(resp_buf, sizeof(resp_buf));
+
   resp = (pr_response_t *) pcalloc(resp_pool, sizeof(pr_response_t));
   resp->num = (numeric ? pstrdup(resp_pool, numeric) : NULL);
   resp->msg = pstrdup(resp_pool, resp_buf);
