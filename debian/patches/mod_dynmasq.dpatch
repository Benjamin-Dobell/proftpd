#! /bin/sh /usr/share/dpatch/dpatch-run
## mod_dynmasq.dpatch by Francesco Paolo Lovergine <frankie@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad trunk~/contrib/mod_dynmasq.c trunk/contrib/mod_dynmasq.c
--- trunk~/contrib/mod_dynmasq.c	1970-01-01 01:00:00.000000000 +0100
+++ trunk/contrib/mod_dynmasq.c	2007-07-20 23:46:11.000000000 +0200
@@ -0,0 +1,203 @@
+/*
+ * ProFTPD: mod_dynmasq -- a module for dynamically updating MasqueradeAddress
+ *                         configurations, as when DynDNS names are used
+ *
+ * Copyright (c) 2004-2007 TJ Saunders
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * As a special exemption, TJ Saunders and other respective copyright holders
+ * give permission to link this program with OpenSSL, and distribute the
+ * resulting executable, without including the source code for OpenSSL in the
+ * source distribution.
+ *
+ * This is mod_dynmasq, contrib software for proftpd 1.2.x and above.
+ * For more information contact TJ Saunders <tj@castaglia.org>.
+ *
+ * $Id: mod_dynmasq.c,v 1.2 2007/07/20 21:45:07 tj Exp tj $
+ */
+
+#include "conf.h"
+
+#define MOD_DYNMASQ_VERSION		"mod_dynmasq/0.2"
+
+/* Make sure the version of proftpd is as necessary. */
+#if PROFTPD_VERSION_NUMBER < 0x0001030005
+# error "ProFTPD 1.3.0 or later required"
+#endif
+
+extern xaset_t *server_list;
+module dynmasq_module;
+static int dynmasq_timer_id = -1;
+static int dynmasq_timer_interval = -1;
+
+/* Configuration handlers
+ */
+
+/* usage: DynMasqRefresh <seconds> */
+MODRET set_dynmasqrefresh(cmd_rec *cmd) {
+  CHECK_CONF(cmd, CONF_ROOT);
+  CHECK_ARGS(cmd, 1);
+
+  dynmasq_timer_interval = atoi(cmd->argv[1]);
+  if (dynmasq_timer_interval < 1)
+    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool,
+      "must be greater than zero: '", cmd->argv[1], "'", NULL));
+
+  return HANDLED(cmd);
+}
+
+/* Timers
+ */
+
+static int dynmasq_update_cb(CALLBACK_FRAME) {
+  server_rec *s;
+
+  pr_log_pri(PR_LOG_DEBUG, MOD_DYNMASQ_VERSION
+    ": resolving all MasqueradeAddress directives (could take a little while)");
+
+  for (s = (server_rec *) server_list->xas_list; s; s = s->next) {
+    config_rec *c = find_config(s->conf, CONF_PARAM, "MasqueradeAddress",
+      FALSE);
+
+    if (c) {
+      pr_netaddr_t *na = pr_netaddr_get_addr(s->pool, c->argv[1], NULL);
+
+      if (na) {
+        /* Compare the obtained netaddr with the one already present.
+         * Only update the "live" netaddr if they differ.
+         */
+        pr_log_pri(PR_LOG_DEBUG, MOD_DYNMASQ_VERSION
+          ": resolved MasqueradeAddress '%s' to IP address %s",
+          (const char *) c->argv[1], pr_netaddr_get_ipstr(na));
+
+        if (pr_netaddr_cmp(c->argv[0], na) != 0) {
+          pr_log_pri(PR_LOG_DEBUG, MOD_DYNMASQ_VERSION
+            ": MasqueradeAddress '%s' updated for new address %s (was %s)",
+            (const char *) c->argv[1], pr_netaddr_get_ipstr(na),
+            pr_netaddr_get_ipstr(c->argv[0]));
+
+          /* Overwrite the old netaddr pointer.  Note that this constitutes
+           * a minor memory leak, as there currently isn't a way to free
+           * the memory used by a netaddr object.  Hrm.
+           */
+          c->argv[0] = na;
+
+        } else
+          pr_log_pri(PR_LOG_DEBUG, MOD_DYNMASQ_VERSION
+            ": MasqueradeAddress '%s' has not changed addresses",
+            (const char *) c->argv[1]);
+ 
+      } else
+        pr_log_pri(PR_LOG_NOTICE, MOD_DYNMASQ_VERSION
+          ": unable to resolve '%s', keep previous address",
+          (const char *) c->argv[1]);
+    }
+  }
+
+  return 1;
+}
+
+/* Event handlers
+ */
+
+#if defined(PR_SHARED_MODULE)
+static void dynmasq_mod_unload_ev(const void *event_data, void *user_data) {
+  if (strcmp("mod_dynmasq.c", (const char *) event_data) == 0) {
+    pr_timer_remove(dynmasq_timer_id, &dynmasq_module);
+    dynmasq_timer_id = -1;
+
+    pr_event_unregister(&dynmasq_module, NULL, NULL);
+  }
+}
+#endif /* !PR_SHARED_MODULE */
+
+static void dynmasq_restart_ev(const void *event_data, void *user_data) {
+  if (dynmasq_timer_id != -1) {
+    pr_timer_remove(dynmasq_timer_id, &dynmasq_module);
+    dynmasq_timer_id = -1;
+  }
+}
+
+static void dynmasq_startup_ev(const void *event_data, void *user_data) {
+  if (dynmasq_timer_interval != -1) {
+    dynmasq_timer_id = pr_timer_add(dynmasq_timer_interval, -1,
+      &dynmasq_module, dynmasq_update_cb);
+  }
+}
+
+/* Initialization functions
+ */
+
+static int dynmasq_init(void) {
+#if defined(PR_SHARED_MODULE)
+  pr_event_register(&dynmasq_module, "core.module-unload",
+    dynmasq_mod_unload_ev, NULL);
+#endif /* !PR_SHARED_MODULE */
+
+  pr_event_register(&dynmasq_module, "core.restart", dynmasq_restart_ev,
+    NULL);
+  pr_event_register(&dynmasq_module, "core.startup", dynmasq_startup_ev,
+    NULL);
+
+  return 0;
+}
+
+static int dynmasq_sess_init(void) {
+
+  /* Ensure that the timer only fires on the daemon process. */
+  pr_timer_remove(dynmasq_timer_id, &dynmasq_module);
+  dynmasq_timer_id = -1;
+
+  pr_event_unregister(&dynmasq_module, "core.restart", NULL);
+
+  return 0;
+}
+
+/* Module API tables
+ */
+
+static conftable dynmasq_conftab[] = {
+  { "DynMasqRefresh",	set_dynmasqrefresh,	NULL },
+  { NULL }
+};
+
+module dynmasq_module = {
+  NULL, NULL,
+
+  /* Module API version 2.0 */
+  0x20,
+
+  /* Module name */
+  "dynmasq",
+
+  /* Module configuration handler table */
+  dynmasq_conftab,
+
+  /* Module command handler table */
+  NULL,
+
+  /* Module authentication handler table */
+  NULL,
+
+  /* Module initialization function */
+  dynmasq_init,
+
+  /* Session initialization function */
+  dynmasq_sess_init,
+
+  /* Module version */
+  MOD_DYNMASQ_VERSION
+};
diff -urNad trunk~/doc/contrib/mod_dynmasq.html trunk/doc/contrib/mod_dynmasq.html
--- trunk~/doc/contrib/mod_dynmasq.html	1970-01-01 01:00:00.000000000 +0100
+++ trunk/doc/contrib/mod_dynmasq.html	2004-07-31 03:36:53.000000000 +0200
@@ -0,0 +1,115 @@
+<!-- $Id: mod_dynmasq.html,v 1.2 2004/07/31 01:36:37 tj Exp tj $ -->
+<!-- $Source: /home/tj/proftpd/modules/doc/RCS/mod_dynmasq.html,v $ -->
+
+<html>
+<head>
+<title>ProFTPD module mod_dynmasq</title>
+</head>
+
+<body bgcolor=white>
+
+<hr>
+<center>
+<h2><b>ProFTPD module <code>mod_dynmasq</code></b></h2>
+</center>
+<hr><br>
+
+The <code>mod_dynmasq</code> module is designed for those sites that
+use the <code>MasqueradeAddress</code> directive in conjunction with DNS
+names whose addresses periodically change, <i>e.g.</i> &quot;dyndns&quot;
+addresses.  The <code>proftpd</code> daemon is not aware of any changes
+to the IP address for a <code>MasqueradeAddress</code> that happen after
+the daemon has started up.  The <code>mod_dynmasq</code> module periodically
+checks all configured <code>MasqueradeAddress</code> directives and resolves
+their IP addresses, updating the stored addresses as needed.
+
+<p>
+This module is contained in the <code>mod_dynmasq.c</code> file for
+ProFTPD 1.2.10 and later, and is not compiled by default.  Installation
+instructions are discussed <a href="#Installation">here</a>.
+
+<p>
+The most current version of <code>mod_dynmasq</code> can be found at:
+<pre>
+  <a href="http://www.castaglia.org/proftpd/">http://www.castaglia.org/proftpd/</a>
+</pre>
+
+<h2>Author</h2>
+<p>
+Please contact TJ Saunders &lt;tj <i>at</i> castaglia.org&gt; with any
+questions, concerns, or suggestions regarding this module.
+
+<h2>Directives</h2>
+<ul>
+  <li><a href="#DynMasqRefresh">DynMasqRefresh</a>
+</ul>
+
+<hr>
+<h2><a name="DynMasqRefresh">DynMasqRefresh</a></h2>
+<strong>Syntax:</strong> DynMasqRefresh <em>secs</em><br>
+<strong>Default:</strong> None<br>
+<strong>Context:</strong> &quot;server config&quot;<br>
+<strong>Module:</strong> mod_dynmasq<br>
+<strong>Compatibility:</strong> 1.2.10
+
+<p>
+The <code>DynMasqRefresh</code> directive configures the amount of time,
+in seconds, between <code>mod_dynmasq</code>'s checking and updating of
+all <code>MasqueradeAddress</code> directives.  If no
+<code>DynMasqRefresh</code> directive is configured, then the module will
+do no checking.
+
+<p>
+The process of resolving a DNS name to its IP address can, depending on
+the DNS configuration, take a noticeable amount of time.  This, combined
+with the number of <code>MasqueradeAddress</code> directives in your
+<code>proftpd.conf</code>, can cause <code>mod_dynmasq</code> to make
+the daemon unavailable while it resolves all addresses.  Therefore it
+is highly recommended that the configured interval be as long as possible,
+for example for 8 hours.
+
+<p>
+Example:
+<pre>
+  &lt;IfModule mod_dynmasq.c&gt;
+    # Refresh any configured MasqueradeAddress directives every 8 hours
+    DynMasqRefresh 28800
+  &lt;/IfModule&gt;
+</pre>
+
+<p>
+See also:
+
+<p>
+<hr>
+<h2><a name="Installation">Installation</a></h2>
+To install <code>mod_dynmasq</code>, copy the <code>mod_dynmasq.c</code> file
+into <pre>
+  <i>proftpd-dir</i>/contrib/
+</pre>
+after unpacking the latest proftpd-1.2.<i>x</i> source code.  Then follow the
+usual steps for using third-party modules in proftpd:
+<pre>
+  ./configure --with-modules=mod_dynmasq
+  make
+  make install
+</pre>
+
+<p>
+<hr><br>
+
+Author: <i>$Author: tj $</i><br>
+Last Updated: <i>$Date: 2004/07/31 01:36:37 $</i><br>
+
+<br><hr>
+
+<font size=2><b><i>
+&copy; Copyright 2004 TJ Saunders<br>
+ All Rights Reserved<br>
+</i></b></font>
+
+<hr><br>
+
+</body>
+</html>
+
