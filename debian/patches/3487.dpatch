#! /bin/sh /usr/share/dpatch/dpatch-run
## 3487.dpatch by Francesco Paolo Lovergine <frankie@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' proftpd-dfsg~/modules/mod_ls.c proftpd-dfsg/modules/mod_ls.c
--- proftpd-dfsg~/modules/mod_ls.c	2010-09-13 15:38:16.000000000 +0200
+++ proftpd-dfsg/modules/mod_ls.c	2010-09-14 10:46:32.000000000 +0200
@@ -303,7 +303,8 @@
         errno != 0) {
       int xerrno = errno;
 
-      if (session.d) {
+      if (session.d &&
+          session.d->outstrm) {
         xerrno = PR_NETIO_ERRNO(session.d->outstrm);
       }
 
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' proftpd-dfsg~/src/data.c proftpd-dfsg/src/data.c
--- proftpd-dfsg~/src/data.c	2010-09-13 15:38:16.000000000 +0200
+++ proftpd-dfsg/src/data.c	2010-09-14 10:46:32.000000000 +0200
@@ -894,6 +894,11 @@
        * already have a data transfer in progress.  For any data transfer
        * command, send a 450 ("busy") reply.  Looks like almost all of the
        * data transfer commands accept that response, as per RFC959.
+       *
+       * We also prevent the EPRT, EPSV, PASV, and PORT commands, since
+       * they will also interfere with the current data transfer.  In doing
+       * so, we break RFC compliance a little; RFC959 does not allow a
+       * response code of 450 for those commands (although it should).
        */
       if (strcmp(cmd->argv[0], C_APPE) == 0 ||
           strcmp(cmd->argv[0], C_LIST) == 0 ||
@@ -901,7 +906,11 @@
           strcmp(cmd->argv[0], C_NLST) == 0 ||
           strcmp(cmd->argv[0], C_RETR) == 0 ||
           strcmp(cmd->argv[0], C_STOR) == 0 ||
-          strcmp(cmd->argv[0], C_STOU) == 0) {
+          strcmp(cmd->argv[0], C_STOU) == 0 ||
+          strcmp(cmd->argv[0], C_PORT) == 0 ||
+          strcmp(cmd->argv[0], C_EPRT) == 0 ||
+          strcmp(cmd->argv[0], C_PASV) == 0 ||
+          strcmp(cmd->argv[0], C_EPSV) == 0) {
         pool *resp_pool;
 
         pr_trace_msg(trace_channel, 5,
