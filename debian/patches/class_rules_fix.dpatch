#! /bin/sh /usr/share/dpatch/dpatch-run
## class_rules_fix.dpatch by Francesco Paolo Lovergine <frankie@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad trunk~/include/netacl.h trunk/include/netacl.h
--- trunk~/include/netacl.h	2008-04-01 16:34:05.000000000 +0200
+++ trunk/include/netacl.h	2008-04-04 17:34:56.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * ProFTPD - FTP server daemon
- * Copyright (c) 2003 The ProFTPD Project team
+ * Copyright (c) 2003-2008 The ProFTPD Project team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -66,4 +66,7 @@
 /* Returns the ACL type. */
 pr_netacl_type_t pr_netacl_get_type(pr_netacl_t *);
 
+/* Returns a string describing the given NetACL. */
+const char *pr_netacl_get_str(pool *, pr_netacl_t *);
+
 #endif /* PR_NETACL_H */
diff -urNad trunk~/src/class.c trunk/src/class.c
--- trunk~/src/class.c	2008-04-01 16:34:05.000000000 +0200
+++ trunk/src/class.c	2008-04-04 17:34:56.000000000 +0200
@@ -28,6 +28,8 @@
 
 #include "conf.h"
 
+static const char *trace_channel = "class";
+
 /* Store the defined Classes in a linked list.  If many Classes are defined,
  * this may need to be redefined to be a collision-chained hash.
  */
@@ -42,13 +44,16 @@
 }
 
 pr_class_t *pr_class_match_addr(pr_netaddr_t *addr) {
-  pr_class_t *cls;
+  pr_class_t *cls, *res = NULL;
+  pool *tmp_pool;
 
   if (!addr) {
     errno = EINVAL;
     return NULL;
   }
 
+  tmp_pool = make_sub_pool(permanent_pool);
+
   for (cls = class_list; cls; cls = cls->cls_next) {
     array_header *acl_list = cls->cls_acls;
     pr_netacl_t **acls = acl_list->elts;
@@ -66,11 +71,25 @@
 
       switch (cls->cls_satisfy) {
         case PR_CLASS_SATISFY_ANY:
+          if (acls[i]) {
+            pr_trace_msg(trace_channel, 6,
+              "checking addr '%s' against class '%s', ACL %s "
+              "(requires any ACL matching)", pr_netaddr_get_ipstr(addr),
+              cls->cls_name, pr_netacl_get_str(tmp_pool, acls[i]));
+          }
+
           if (pr_netacl_match(acls[i], addr) == 1)
-            return cls;
+            res = cls;
           break;
 
         case PR_CLASS_SATISFY_ALL:
+          if (acls[i]) {
+            pr_trace_msg(trace_channel, 6,
+              "checking addr '%s' against class '%s', ACL %s "
+              "(requires all ACLs matching)", pr_netaddr_get_ipstr(addr),
+              cls->cls_name, pr_netacl_get_str(tmp_pool, acls[i]));
+          }
+
           if (pr_netacl_match(acls[i], addr) == 0)
             next_class = TRUE;
           break;
@@ -78,8 +97,12 @@
     }
   }
 
-  errno = ENOENT;
-  return NULL;
+  destroy_pool(tmp_pool);
+
+  if (res == NULL)
+    errno = ENOENT;
+
+  return res;
 }
 
 pr_class_t *pr_class_find(const char *name) {
diff -urNad trunk~/src/netacl.c trunk/src/netacl.c
--- trunk~/src/netacl.c	2008-04-01 16:34:05.000000000 +0200
+++ trunk/src/netacl.c	2008-04-04 17:35:26.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * ProFTPD - FTP server daemon
- * Copyright (c) 2003-2006 The ProFTPD Project team
+ * Copyright (c) 2003-2008 The ProFTPD Project team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -46,27 +46,43 @@
   return acl->type;
 }
 
+/* Returns 1 if there was a positive match, -1 if there was a negative
+ * match, -2 if there was an error, and zero if there was no match at all.
+ */
 int pr_netacl_match(pr_netacl_t *acl, pr_netaddr_t *addr) {
+  pool *tmp_pool;
 
   if (!acl || !addr)
     return -2;
 
+tmp_pool = make_sub_pool(permanent_pool);
+
   switch (acl->type) {
     case PR_NETACL_TYPE_ALL:
-      pr_trace_msg(trace_channel, 10, "addr '%s' matched rule 'ALL'",
-        pr_netaddr_get_ipstr(addr));
-      return 1;
+      pr_trace_msg(trace_channel, 10, "addr '%s' matched rule 'ALL' ('%s')",
+        pr_netaddr_get_ipstr(addr), pr_netacl_get_str(tmp_pool, acl));
+      if (!acl->negated)
+        return 1;
+      else
+        return -1;
 
     case PR_NETACL_TYPE_NONE:
       pr_trace_msg(trace_channel, 10, "addr '%s' matched rule 'NONE'",
         pr_netaddr_get_ipstr(addr));
-      return -1;
+      if (!acl->negated)
+        return -1;
+      else
+        return 1;
 
     case PR_NETACL_TYPE_IPMASK:
       if (pr_netaddr_ncmp(addr, acl->addr, acl->masklen) == 0) {
         pr_trace_msg(trace_channel, 10, "addr '%s' matched IP mask rule '%s'",
           pr_netaddr_get_ipstr(addr), acl->aclstr);
         return 1;
+
+      } else {
+        if (acl->negated)
+          return 1;
       }
       break;
 
@@ -76,6 +92,10 @@
           "addr '%s' matched IP address rule '%s'",
           pr_netaddr_get_ipstr(addr), acl->aclstr);
         return 1;
+
+      } else {
+        if (acl->negated)
+          return 1;
       }
       break;
  
@@ -86,6 +106,10 @@
           pr_netaddr_get_ipstr(addr), pr_netaddr_get_dnsstr(addr),
           acl->aclstr);
         return 1;
+
+      } else {
+        if (acl->negated)
+          return 1;
       }
       break;
 
@@ -96,6 +120,10 @@
           "addr '%s' matched IP glob rule '%s'",
           pr_netaddr_get_ipstr(addr), acl->aclstr);
         return 1;
+
+      } else {
+        if (acl->negated)
+          return 1;
       }
       break;
 
@@ -108,6 +136,10 @@
             pr_netaddr_get_ipstr(addr), pr_netaddr_get_dnsstr(addr),
             acl->aclstr);
           return 1;
+
+        } else {
+          if (acl->negated)
+            return 1;
         }
 
       } else {
@@ -317,3 +349,58 @@
 
   return acl->negated;
 }
+
+const char *pr_netacl_get_str(pool *p, pr_netacl_t *acl) {
+  char *res = "";
+
+  if (!p || !acl) {
+    errno = EINVAL;
+    return NULL;
+  }
+
+  res = pstrcat(p, res, acl->aclstr, NULL);
+
+  switch (acl->type) {
+    case PR_NETACL_TYPE_ALL:
+      res = pstrcat(p, res, " <all>", NULL);
+      break;
+
+    case PR_NETACL_TYPE_NONE:
+      res = pstrcat(p, res, " <none>", NULL);
+      break;
+
+    case PR_NETACL_TYPE_IPMASK: {
+      char masklenstr[64];
+
+      memset(masklenstr, '\0', sizeof(masklenstr));
+      snprintf(masklenstr, sizeof(masklenstr)-1, "%u", acl->masklen);
+      res = pstrcat(p, res, " <IP address mask, ", masklenstr, "-bit mask, ",
+        NULL);
+      break;
+    }
+
+    case PR_NETACL_TYPE_IPMATCH:
+      res = pstrcat(p, res, " <IP address match", NULL);
+      break;
+
+    case PR_NETACL_TYPE_DNSMATCH:
+      res = pstrcat(p, res, " <DNS hostname match", NULL);
+      break;
+
+    case PR_NETACL_TYPE_IPGLOB:
+      res = pstrcat(p, res, " <IP address glob", NULL);
+      break;
+
+    case PR_NETACL_TYPE_DNSGLOB:
+      res = pstrcat(p, res, " <DNS hostname glob", NULL);
+      break;
+  }
+
+  if (!acl->negated)
+    res = pstrcat(p, res, ">", NULL);
+  else
+    res = pstrcat(p, res, ", inverted>", NULL);
+
+  return res;
+}
+
